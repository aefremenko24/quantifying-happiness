//
//  SuggestionsView.swift
//  HealthTracker/Views
//
//  Created by Arthur Efremenko on 10/26/25.
//

import SwiftUI
import SwiftData


/// Displays suggestions for how the user could adjust their habits 
/// to move toward a potentially better satisfaction outcome based
/// off of suggestions given by our model.
///
/// 'SuggestionsView' compares the current day's 'SatisfactionEntry' to a
/// suggested target entry generated by a simulated annealing optimizer.
/// For each metric, it shows:
///  - the metric name,
///  - the absolute difference between the current and suggested values,
///  - an arrow up or down indicating whether to increase or decrease,
///  - a dash if no change is suggested.
///
/// When the view appears, it asynchronously loads suggestions from
/// historical data. While suggestions are being computed, a placeholder
/// “Loading suggestions” message is shown to the user.
struct SuggestionsView: View {
    @Environment(\.modelContext) private var context
    
    var currentSatisfactionEntry: SatisfactionEntry
    @State var suggestedSatisfactionEntry: SatisfactionEntry?
    
    var body: some View {
        VStack(alignment: .leading, spacing: 5) {
            if suggestedSatisfactionEntry == nil {
                Text("Loading suggestions...")
            } else {
                let metricNames = SatisfactionEntry.metricNamesList()
                let currentMetricValues: [Double] = currentSatisfactionEntry.toList()
                let suggestedMetricValues: [Double] = suggestedSatisfactionEntry!.toList()
                ForEach(Array(metricNames.enumerated()), id: \.offset) { index, metricName in
                    let metricDiff: Int = Int(suggestedMetricValues[index] - currentMetricValues[index])
                    let color: Color = metricDiff < 0 ? .red : metricDiff == 0 ? .primary : .green
                    HStack {
                        Text(metricName)
                            .font(.headline)
                        Spacer()
                        Text("\(abs(metricDiff))")
                            .font(.headline)
                            .fontWeight(.bold)
                            .foregroundStyle(color)
                        
                        if metricDiff == 0 {
                            Text("—")
                                .foregroundStyle(color)
                        } else {
                            Image(systemName: metricDiff < 0 ? "chevron.down" : "chevron.up")
                                .foregroundStyle(color)
                        }
                    }
                    .padding()
                }
            }
        }
        .onAppear() {
            Task {
                await loadSuggestions()
            }
        }
    }

    /// Loads a suggested satisfaction entry using simulated annealing over
    /// the user's historical data.
    ///
    /// This method fetches all 'SatisfactionEntry' records that don't have a nil score,
    /// constructs a 'SimulatedAnnealingOptimizer' using those entries as the search space,
    /// runs the optimizer starting from 'currentSatisfactionEntry', and updates 
    /// 'suggestedSatisfactionEntry' with the optimizer’s result.
    ///
    /// Updates the 'suggestedSatisfactionEntry' state in place when
    /// optimization succeeds.
    ///
    /// - Throws:
    ///   - 'SimulatedAnnealingOptimizerError.invalidInitialParameters' 
    ///     if the optimizer determines that the starting parameters are invalid.
    ///   - 'SimulatedAnnealingOptimizerError.stepComputationFailed'
    ///     if a step cannot be computed due to invalid or missing metric values.
    ///   - 'SimulatedAnnealingOptimizerError.noFeasibleSolution'
    ///     if the optimizer cannot produce a valid optimized entry.
    ///   - Errors thrown during SwiftData fetch operations if the context
    ///     fails to retrieve historical entries.
    func loadSuggestions() async {
        let descriptor = FetchDescriptor<SatisfactionEntry>(
            predicate: #Predicate { $0.userSatisfactionScore != nil }
        )
        let fetchedModels: [SatisfactionEntry]
        do {
            fetchedModels = try context.fetch(descriptor)
        } catch {
            print("Could not fetch SatisfactionEntries: \(error)")
            return
        }
        let optimizer = SimulatedAnnealingOptimizer(
            data: fetchedModels,
            initialTemperature: 100.0,
            coolingRate: 0.95,
            stepSize: 0.25
        )
        do {
            let optimizerOutput = try optimizer.optimize(initialParams: currentSatisfactionEntry, maxIterations: 500)
            self.suggestedSatisfactionEntry = optimizerOutput.value
        } catch {
            print("Optimization failed: \(error)")
            return
        }
    }
}

#Preview {
    var currentSatisfactionEntry = SatisfactionEntry(from: [10298, 338, 621.67, 80, 18, 125, 7552.17, 7, 71], satisfactionScore: 10) ?? SatisfactionEntry(day: Date(), score: 10)
    var suggestedSatisfactionEntry = SatisfactionEntry(from: [13902, 434, 547.22, 21, 16, 237, 10293.95, 7, 60], satisfactionScore: 5) ?? SatisfactionEntry(day: Date(), score: 10)
    
    SuggestionsView(currentSatisfactionEntry: currentSatisfactionEntry, suggestedSatisfactionEntry: suggestedSatisfactionEntry)
}
